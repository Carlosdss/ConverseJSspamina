{"version":3,"sources":["../src/pluggable.js"],"names":[],"mappings":"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","file":"pluggable.js","sourcesContent":["/*\n       ____  __                        __    __         _\n      / __ \\/ /_  __ ___   ___  ____ _/ /_  / /__      (_)____\n     / /_/ / / / / / __ \\/ __ \\/ __/ / __ \\/ / _ \\    / / ___/\n    / ____/ / /_/ / /_/ / /_/ / /_/ / /_/ / /  __/   / (__  )\n   /_/   /_/\\__,_/\\__, /\\__, /\\__/_/_.___/_/\\___(_)_/ /____/\n                 /____//____/                    /___/\n */\n\n// Pluggable.js lets you to make your Javascript code pluggable while still\n// keeping sensitive objects and data private through closures.\n\n/*global console */\n\nimport * as _ from 'lodash';\n\n// The `PluginSocket` class contains the plugin architecture, and gets\n// created whenever `pluggable.enable(obj);` is called on the object\n// that you want to make pluggable.\n// You can also see it as the thing into which the plugins are plugged.\n// It takes two parameters, first, the object being made pluggable, and\n// then the name by which the pluggable object may be referenced on the\n// __super__ object (inside overrides).\nfunction PluginSocket (plugged, name) {\n    this.name = name;\n    this.plugged = plugged;\n    if (typeof this.plugged.__super__ === 'undefined') {\n        this.plugged.__super__ = {};\n    } else if (typeof this.plugged.__super__ === 'string') {\n        this.plugged.__super__ = { '__string__': this.plugged.__super__ };\n    }\n    this.plugged.__super__[name] = this.plugged;\n    this.plugins = {};\n    this.initialized_plugins = [];\n}\n\n// Now we add methods to the PluginSocket by adding them to its\n// prototype.\n_.extend(PluginSocket.prototype, {\n\n    // `wrappedOverride` creates a partially applied wrapper function\n    // that makes sure to set the proper super method when the\n    // overriding method is called. This is done to enable\n    // chaining of plugin methods, all the way up to the\n    // original method.\n    wrappedOverride: function (key, value, super_method, default_super) {\n        if (typeof super_method === \"function\") {\n            if (typeof this.__super__ === \"undefined\") {\n                /* We're not on the context of the plugged object.\n                 * This can happen when the overridden method is called via\n                 * an event handler or when it's a constructor.\n                 *\n                 * In this case, we simply tack on the  __super__ obj.\n                 */\n                this.__super__ = default_super;\n            }\n            this.__super__[key] = super_method.bind(this);\n        }\n        return value.apply(this, _.drop(arguments, 4));\n    },\n\n    // `_overrideAttribute` overrides an attribute on the original object\n    // (the thing being plugged into).\n    //\n    // If the attribute being overridden is a function, then the original\n    // function will still be available via the `__super__` attribute.\n    //\n    // If the same function is being overridden multiple times, then\n    // the original function will be available at the end of a chain of\n    // functions, starting from the most recent override, all the way\n    // back to the original function, each being referenced by the\n    // previous' __super__ attribute.\n    //\n    // For example:\n    //\n    // `plugin2.MyFunc.__super__.myFunc => plugin1.MyFunc.__super__.myFunc => original.myFunc`\n    _overrideAttribute: function (key, plugin) {\n        let value = plugin.overrides[key];\n        if (typeof value === \"function\") {\n            let default_super = {};\n            default_super[this.name] = this.plugged;\n\n            let wrapped_function = _.partial(\n                this.wrappedOverride, key, value, this.plugged[key],  default_super\n            );\n            this.plugged[key] = wrapped_function;\n        } else {\n            this.plugged[key] = value;\n        }\n    },\n\n    _extendObject: function (obj, attributes) {\n        if (!obj.prototype.__super__) {\n            obj.prototype.__super__ = {};\n            obj.prototype.__super__[this.name] = this.plugged;\n        }\n        let that = this;\n        _.each(attributes, function (value, key) {\n            if (key === 'events') {\n                obj.prototype[key] = _.extend(value, obj.prototype[key]);\n            } else if (typeof value === 'function') {\n                // We create a partially applied wrapper function, that\n                // makes sure to set the proper super method when the\n                // overriding method is called. This is done to enable\n                // chaining of plugin methods, all the way up to the\n                // original method.\n                let default_super = {};\n                default_super[that.name] = that.plugged;\n\n                let wrapped_function = _.partial(\n                    that.wrappedOverride, key, value, obj.prototype[key], default_super\n                );\n                obj.prototype[key] = wrapped_function;\n            } else {\n                obj.prototype[key] = value;\n            }\n        });\n    },\n\n    // Plugins can specify optional dependencies (by means of the\n    // `optional_dependencies` list attribute) which refers to dependencies\n    // which will be initialized first, before the plugin itself gets initialized.\n    // They are optional in the sense that if they aren't available, an\n    // error won't be thrown.\n    // However, if you want to make these dependencies strict (i.e.\n    // non-optional), you can set the `strict_plugin_dependencies` attribute to `true`\n    // on the object being made pluggable (i.e. the object passed to\n    // `pluggable.enable`).\n    loadOptionalDependencies: function (plugin) {\n        _.each(plugin.optional_dependencies, (name) => {\n            let dep = this.plugins[name];\n            if (dep) {\n                if (_.includes(dep.optional_dependencies, plugin.__name__)) {\n                    /* FIXME: circular dependency checking is only one level deep. */\n                    throw \"Found a circular dependency between the plugins \\\"\"+\n                        plugin.__name__+\"\\\" and \\\"\"+name+\"\\\"\";\n                }\n                this.initializePlugin(dep);\n            } else {\n                this.throwUndefinedDependencyError(\n                    \"Could not find optional dependency \\\"\"+name+\"\\\" \"+\n                    \"for the plugin \\\"\"+plugin.__name__+\"\\\". \"+\n                    \"If it's needed, make sure it's loaded by require.js\");\n            }\n        });\n    },\n\n    throwUndefinedDependencyError: function (msg) {\n        if (this.plugged.strict_plugin_dependencies) {\n            throw msg;\n        } else {\n            console.log(msg);\n            return;\n        }\n    },\n\n    // `applyOverrides` is called by initializePlugin. It applies any\n    // and all overrides of methods or Backbone views and models that\n    // are defined on any of the plugins.\n    applyOverrides: function (plugin) {\n        _.each(Object.keys(plugin.overrides || {}), (key) => {\n            let override = plugin.overrides[key];\n            if (typeof override === \"object\") {\n                if (typeof this.plugged[key] === 'undefined') {\n                    this.throwUndefinedDependencyError(\n                        \"Error: Plugin \\\"\"+plugin.__name__+\n                        \"\\\" tried to override \"+key+\" but it's not found.\");\n                } else {\n                    this._extendObject(this.plugged[key], override);\n                }\n            } else {\n                this._overrideAttribute(key, plugin);\n            }\n        });\n    },\n\n    // `initializePlugin` applies the overrides (if any) defined on all\n    // the registered plugins and then calls the initialize method for each plugin.\n    initializePlugin: function (plugin) {\n        if (!_.includes(_.keys(this.allowed_plugins), plugin.__name__)) {\n            /* Don't initialize disallowed plugins. */\n            return;\n        }\n        if (_.includes(this.initialized_plugins, plugin.__name__)) {\n            /* Don't initialize plugins twice, otherwise we get\n            * infinite recursion in overridden methods.\n            */\n            return;\n        }\n        _.extend(plugin, this.properties);\n        if (plugin.optional_dependencies) {\n            this.loadOptionalDependencies(plugin);\n        }\n        this.applyOverrides(plugin);\n        if (typeof plugin.initialize === \"function\") {\n            plugin.initialize.bind(plugin)(this);\n        }\n        this.initialized_plugins.push(plugin.__name__);\n    },\n\n    // `registerPlugin` registers (or inserts, if you'd like) a plugin,\n    // by adding it to the `plugins` map on the PluginSocket instance.\n    registerPlugin: function (name, plugin) {\n        if (name in this.plugins) {\n            throw new Error('Error: Plugin name '+name+' is already taken');\n        }\n        plugin.__name__ = name;\n        this.plugins[name] = plugin;\n    },\n\n    // `initializePlugins` should get called once all plugins have been\n    // registered. It will then iterate through all the plugins, calling\n    // `initializePlugin` for each.\n    // The passed in  properties variable is an object with attributes and methods\n    // which will be attached to the plugins.\n    initializePlugins: function (properties={}, whitelist=[], blacklist=[]) {\n        if (!_.size(this.plugins)) {\n            return;\n        }\n        this.properties = properties;\n        this.allowed_plugins  = _.pickBy(this.plugins,\n            function (plugin, key) {\n                return (!whitelist.length || (whitelist.length && _.includes(whitelist, key))) &&\n                    !_.includes(blacklist, key);\n            }\n        );\n        _.each(_.values(this.allowed_plugins), this.initializePlugin.bind(this));\n    }\n});\n\nfunction enable (object, name, attrname) {\n    // Call the `enable` method to make an object pluggable\n    //\n    // It takes three parameters:\n    // - `object`: The object that gets made pluggable.\n    // - `name`: The string name by which the now pluggable object\n    //     may be referenced on the __super__ obj (in overrides).\n    //     The default value is \"plugged\".\n    // - `attrname`: The string name of the attribute on the now\n    //     pluggable object, which refers to the PluginSocket instance\n    //     that gets created.\n    if (typeof attrname === \"undefined\") {\n        attrname = \"pluginSocket\";\n    }\n    if (typeof name === 'undefined') {\n        name = 'plugged';\n    }\n    let ref = {};\n    ref[attrname] = new PluginSocket(object, name);\n    return _.extend(object, ref);\n}\n\nexport {\n    enable\n};\nexport default {\n    enable\n};\n"]}