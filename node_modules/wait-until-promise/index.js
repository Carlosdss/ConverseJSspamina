(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['exports'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.waitUntilPromise = mod.exports;
  }
})(this, function (exports) {
  'use strict';

  exports.__esModule = true;
  var PromiseImplementation = void 0;

  try {
    PromiseImplementation = Promise;
  } catch (err) {}

  /**
   * Clears the specified timeout and interval.
   *
   * @param {number} timeout - Id if the timeout to clear.
   * @param {number} interval - Id of the interval to clear.
   * @private
   */
  function clearTimers(timeout, interval) {
    clearTimeout(timeout);
    clearInterval(interval);
  }

  /**
   * Set a custom {@link Promise} implementation.
   *
   * @param {Function} implementation - A promise implementation to use instead of native {@link Promise}.
   * @static
   */
  var setPromiseImplementation = exports.setPromiseImplementation = function (implementation) {
    PromiseImplementation = implementation;
  };

  /**
   * Create a {@link Promise} that resolves if the given escapeFunction returns a truthy value, and rejects if it throws
   * or does not return truthy within the given maxWait.
   *
   * @param {Function} escapeFunction - The function called every checkDelay, and the result of which is the resolved
   * value of the promise.
   * @param {number} [maxWait=50] - The time to wait before rejecting the promise.
   * @param {number} [checkDelay=1] - The time to wait before each invocation of {escapeFunction}.
   * @returns {Promise} A promise resolved with the value of escapeFunction, or rejected with the exception thrown by it
   * or it times out.
   */

  exports['default'] = function (escapeFunction) {
    var maxWait = arguments.length <= 1 || arguments[1] === undefined ? 50 : arguments[1];
    var checkDelay = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];

    if (PromiseImplementation == null) {
      throw new Error('Wait Until Promise: No global Promise available, make sure to use `setPromiseImplementation`.');
    }

    // Run the function once without setting up any listeners in case it's already true
    try {
      var escapeFunctionRes = escapeFunction();

      if (escapeFunctionRes) return PromiseImplementation.resolve(escapeFunctionRes);
    } catch (e) {
      return PromiseImplementation.reject(e);
    }

    return new PromiseImplementation(function (resolve, reject) {
      var maxWaitTimeout = void 0;

      var interval = setInterval(function () {
        try {
          var _escapeFunctionRes = escapeFunction();

          if (_escapeFunctionRes) {
            clearTimers(maxWaitTimeout, interval);

            resolve(_escapeFunctionRes);
          }
        } catch (e) {
          clearTimers(maxWaitTimeout, interval);

          reject(e);
        }
      }, checkDelay);

      maxWaitTimeout = setTimeout(function () {
        clearTimers(maxWaitTimeout, interval);

        // Try to reject with a TimeoutError, like Bluebird has
        if (PromiseImplementation.TimeoutError) {
          reject(new PromiseImplementation.TimeoutError('Wait until promise timed out'));
        } else {
          reject(new Error('Wait until promise timed out'));
        }
      }, maxWait);
    });
  };
});
